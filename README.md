# تمرین اول آزمایشگاه نرم‌افزار: کار با گیت
 

 ## مراحل انجام آزمایش

 * ساخت ریپو گیت‌هاب و افزودن فایل `README.md` به آن
 * ساخت بورد کانبان و تعریف تسک‌های اولیه در آن
 * ساخت یک ساختار اولیه و کاملا ساده از سایت با html/css
 * افزودن استقرار مستمر به شاخه main پروژه
 * محافظت از شاخه main با استفاده از ruleهای گیت‌هاب 
 * نیازمندی‌های ابتدایی پروژه به کانبان اضافه و به طور دقیق به قسمت‌های کوچک‌تر شکسته شد
 * افزودن nav
 * افزودن بخش هدینگ به عنوان تیتر و توضیحات بیشتر بخش‌‌های مختلف سایت
 * افزودن فایل `.gitignore` به پروژه
 * اضاقه کردن بخش گالری تصاویر با استفاده از قابلیت‌های grid و flex در bootstrap
 * افزودن فوتر
 * افزودن بخش ارتباط با ما

 ## کارهایی که در نهایت باید انجام شوند

 - [x] ساخت فایل ‍‍‍`.gitignore` 
 - [X] حداقل ۲۰ کامیت معنادار داشته باشیم
 - [X] حداقل ۳ شاخه معنادار در پروژه داشته باشیم
 - [X] حداقل ۲ کانفلیکت برطرف شده باشد
 - [X] شاخه `main` محافظت شوند تا فقط با PR قابل تغییر باشد.
 - [X] استقرار مستمر به کمک Workflow فراهم شود.
 - [X] نوشتن گزارش از مراحل انجام کار
 - [ ] پاسخ به پرسش‌های انتهایی

## پاسخ سوالات انتهایی

#### پوشه `.git` چیست و چه اطلاعاتی در آن ذخیره می‌شود؟

این پوشه با دستوری `git init` ساخته می شود و تمامی اطلاعات مربوط به مدیریت نسخه را در خود نگه می‌دارد.
از جمله این اطلاعات می‌توان به تاریخچه تغییرات، لاگ‌ها، اطلاعات شاخه‌ها و نیز برخی تنظیمات مربوط به مخزن جاری می‌توان اشاره کرد.

####  منظور از atomic بودن در atomic commit و atomic pull-request چیست؟
در اینجا منظور از اتمیک بودن آن است که تغییرات اعمال شده، چه در لایه کامیت و چه در ایجاد `pull request` به کوچک‌ترین حالات ممکن و البته کامل انجام شود. به این معنا که هیچ کامیتی شامل ۲ تغییر نامرتبط به یکدیگر نباشد. بلکه باید شامل یک تغییر کاملا مشخص و نیز مستقل باشد.

در ادامه در هر یک از موارد به طور دقیق‌تر به بررسی این مفهوم می‌پردازیم:

در `atomic commit` به دنبال آن هستیم که کامیت‌هایمان کوچک و غیر‌قابل تفکیک باشند. همانگونه که یک اتم این ویژگی‌ها را داراست.

1. کوچک بودن به این معنا که فقط یک کار مشخص در آن انجام شده باشد و چند تغییر به طور همزمان در یک کامیت ثبت نشده باشند.
2. غیر قابل تفکیک بودن  اما به این معناست که تغییرات یک کامیت نباید قابل تفکیک به بخش‌های کوچک‌تر باشد. در این صورت چنانچه نیاز به رول‌بک آن کامیت باشد کافیست تمام کامیت برگردانده شود و نه بخشی از آن.

در `atomic pull request` نیز به دنبال آن هستیم که هر `pr` به یک ویژگی، قابلیت و یا اصلاح خاصی اختصاص یابد و مستقل از دیگر pr ها بتواند عمل کند.

در این حالت، بررسی و ادغام pr مورد نظر به مراتب ساده‌تر و سریع‌تر خواهد بود.

#### تفاوت دستورهای fetch و pull و merge و rebase و cherry-pick را بیان کنید.
دستور `fetch` آخرین تغییرات را از repo ریموت دریافت می‌کند. در نتیجه این بروزرسانی، تغییرات ریموت در مخزن محلی (local) ما نیز ذخیره خواهد شد. اما توجه شود که این تغییرات روی هیچ یک از شاخه‌های جاری شما اعمال نمی‌شود، بلکه صرفا دریافت می شود.

دستور `pull` مشابه دستور `fetch` عمل می‌کند با این تفاوت که پس از دریافت تغییرات، آنها را با شاخه فعلی نیز ادغام می‌کند.
با این توصیف می‌توان گقت این دستور به نوعی ترکیبی از دو دستور `fetch‍` و `merge` است.

دستور `merge` برای ادغام شاخه‌ها در یکدیگر استفاده می‌شود. به این معنا که تغییرات شاخه مشخصی را روی شاخه دیگری (شاخه جاری) اعمال می‌کند.

دستور `rebase` به طور کلی برای ترکیب دو شاخه با یکدیگر استفاده می‌شود، اما تفاوت مهم آن با `merge` آن است که در اینجا تغییرات، در ادامه آخرین تغییر شاخه دیگر اضافه می‌شود و به همین علت، تاریخچه پروژه به صورت خطی باقی می‌ماند. 

در واقع، تفاوت اصلی بین `rebase` و `merge` در نحوه ادغام تغییرات و نهایتا مدیریت تاریخچه پروژه است.
اگر از `merge` استفاده کنیم تغییرات دو شاخه به صورت موازی ادغام می‌شوند و کامیت جدید با عنوان ادغام دو شاخه نیز ایجاد می‌کند. در نتیجه این نحوه ادغام، تاریخچه پروژه به صورت غیر خطی خواهد بود.

در `rebase` اما تغییرات یک شاخه برروی شاخه دیگر قرار می‌گیرد به گونه‌ای که انگار تمامی این تغییرات، بر اساس آخرین تغییرات شاخه دیگر انجام شده است و در ادامه آن آمده. در نتیجه تاریخچه پروژه به صورت خطی باقی خواهد ماند و منظم‌تر خواهد بود.

