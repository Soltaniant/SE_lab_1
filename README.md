# تمرین اول آزمایشگاه نرم‌افزار: کار با گیت
 

 ## مراحل انجام آزمایش

 * ساخت ریپو گیت‌هاب و افزودن فایل `README.md` به آن
 * ساخت بورد کانبان و تعریف تسک‌های اولیه در آن
 * ساخت یک ساختار اولیه و کاملا ساده از سایت با html/css
 * افزودن استقرار مستمر به شاخه main پروژه
 * محافظت از شاخه main با استفاده از ruleهای گیت‌هاب 
 * نیازمندی‌های ابتدایی پروژه به کانبان اضافه و به طور دقیق به قسمت‌های کوچک‌تر شکسته شد
 * افزودن nav
 * افزودن بخش هدینگ به عنوان تیتر و توضیحات بیشتر بخش‌‌های مختلف سایت
 * افزودن فایل `.gitignore` به پروژه
 * اضاقه کردن بخش گالری تصاویر با استفاده از قابلیت‌های grid و flex در bootstrap
 * افزودن فوتر
 * افزودن بخش ارتباط با ما
 * نگارش پاسخ سوالات انتهایی آزمایش

 ## کارهایی که در نهایت باید انجام شوند

 - [x] ساخت فایل ‍‍‍`.gitignore` 
 - [X] حداقل ۲۰ کامیت معنادار داشته باشیم
 - [X] حداقل ۳ شاخه معنادار در پروژه داشته باشیم
 - [X] حداقل ۲ کانفلیکت برطرف شده باشد
 - [X] شاخه `main` محافظت شوند تا فقط با PR قابل تغییر باشد.
 - [X] استقرار مستمر به کمک Workflow فراهم شود.
 - [X] نوشتن گزارش از مراحل انجام کار
 - [X] پاسخ به پرسش‌های انتهایی

## پاسخ سوالات انتهایی
    
#### پوشه `.git` چیست و چه اطلاعاتی در آن ذخیره می‌شود؟

این پوشه با دستوری `git init` ساخته می شود و تمامی اطلاعات مربوط به مدیریت نسخه را در خود نگه می‌دارد.
از جمله این اطلاعات می‌توان به تاریخچه تغییرات، لاگ‌ها، اطلاعات شاخه‌ها و نیز برخی تنظیمات مربوط به مخزن جاری می‌توان اشاره کرد.

####  منظور از atomic بودن در atomic commit و atomic pull-request چیست؟
در اینجا منظور از اتمیک بودن آن است که تغییرات اعمال شده، چه در لایه کامیت و چه در ایجاد `pull request` به کوچک‌ترین حالات ممکن و البته کامل انجام شود. به این معنا که هیچ کامیتی شامل ۲ تغییر نامرتبط به یکدیگر نباشد. بلکه باید شامل یک تغییر کاملا مشخص و نیز مستقل باشد.

در ادامه در هر یک از موارد به طور دقیق‌تر به بررسی این مفهوم می‌پردازیم:

در `atomic commit` به دنبال آن هستیم که کامیت‌هایمان کوچک و غیر‌قابل تفکیک باشند. همانگونه که یک اتم این ویژگی‌ها را داراست.

1. کوچک بودن به این معنا که فقط یک کار مشخص در آن انجام شده باشد و چند تغییر به طور همزمان در یک کامیت ثبت نشده باشند.
2. غیر قابل تفکیک بودن  اما به این معناست که تغییرات یک کامیت نباید قابل تفکیک به بخش‌های کوچک‌تر باشد. در این صورت چنانچه نیاز به رول‌بک آن کامیت باشد کافیست تمام کامیت برگردانده شود و نه بخشی از آن.

در `atomic pull request` نیز به دنبال آن هستیم که هر `pr` به یک ویژگی، قابلیت و یا اصلاح خاصی اختصاص یابد و مستقل از دیگر pr ها بتواند عمل کند.

در این حالت، بررسی و ادغام pr مورد نظر به مراتب ساده‌تر و سریع‌تر خواهد بود.

#### تفاوت دستورهای fetch و pull و merge و rebase و cherry-pick را بیان کنید.
دستور `fetch` آخرین تغییرات را از repo ریموت دریافت می‌کند. در نتیجه این بروزرسانی، تغییرات ریموت در مخزن محلی (local) ما نیز ذخیره خواهد شد. اما توجه شود که این تغییرات روی هیچ یک از شاخه‌های جاری شما اعمال نمی‌شود، بلکه صرفا دریافت می شود.

دستور `pull` مشابه دستور `fetch` عمل می‌کند با این تفاوت که پس از دریافت تغییرات، آنها را با شاخه فعلی نیز ادغام می‌کند.
با این توصیف می‌توان گقت این دستور به نوعی ترکیبی از دو دستور `fetch‍` و `merge` است.

دستور `merge` برای ادغام شاخه‌ها در یکدیگر استفاده می‌شود. به این معنا که تغییرات شاخه مشخصی را روی شاخه دیگری (شاخه جاری) اعمال می‌کند.

دستور `rebase` به طور کلی برای ترکیب دو شاخه با یکدیگر استفاده می‌شود، اما تفاوت مهم آن با `merge` آن است که در اینجا تغییرات، در ادامه آخرین تغییر شاخه دیگر اضافه می‌شود و به همین علت، تاریخچه پروژه به صورت خطی باقی می‌ماند. 

در واقع، تفاوت اصلی بین `rebase` و `merge` در نحوه ادغام تغییرات و نهایتا مدیریت تاریخچه پروژه است.
اگر از `merge` استفاده کنیم تغییرات دو شاخه به صورت موازی ادغام می‌شوند و کامیت جدید با عنوان ادغام دو شاخه نیز ایجاد می‌کند. در نتیجه این نحوه ادغام، تاریخچه پروژه به صورت غیر خطی خواهد بود.

در `rebase` اما تغییرات یک شاخه برروی شاخه دیگر قرار می‌گیرد به گونه‌ای که انگار تمامی این تغییرات، بر اساس آخرین تغییرات شاخه دیگر انجام شده است و در ادامه آن آمده. در نتیجه تاریخچه پروژه به صورت خطی باقی خواهد ماند و منظم‌تر خواهد بود.

از `cherry pick` برای اعمال تغییرات یک کامیت مشخص استفاده می‌شود. این کامیت می‌تواند روی هر شاخه‌ای وجود داشته باشد.

####   تفاوت دستورهای reset و revert و restore و switch و checkout را بیان کنید.
از دستور `git reset` برای بازگرداندن `HEAD` به کامیتی خاص استفاده می‌شود. توجه شود که منظور از برگرداندن، صرف تغییر `HEAD` نیست بلکه خود شاخه را نیز به همان نقطه منتقل می کند.

از `git revert` برای برگرداندن تغییرات یک کامیت خاص استفاده می شود. به این معنا که کامیت جدید برای معکوس کردن تغییرات اعمال شده در کامیت دیگر ساخته می‌شود.

> توجه شود که با توجه به مکانیزم `event sourcing` گیت، خود دستور `revert` نیز یک کامیت است!

دستور `git-restore` تغییرات یک فایل را به آخرین تغییرات کامیت‌شده آن باز می‌گرداند. همچنین چنانچه به صورت `git restore --staged` استفاده شود فایل‌ مشخص شده را از استیج نیز خارج می‌کند. به طور مثال چنانچه فایلی را به اشتباه با `git add` به `stage` برده باشیم با این دستور می‌توان آن را از استیج خارج کرد.

دستور `switch` را می‌توان یک دستور جدید در گیت دانست که به نوعی جایگزینی ساده‌ برای دستور `checkout` محسوب می‌شود که فقط و فقط وظیفه جابجایی و ساخت شاخه‌ها را دارد. این درحالی است که دستور `checkout` هر دو دستور `switch` و `restore` را در دل خود داشت.


####     منظور از stage یا همان index چیست؟ دستور stash چه کاری را انجام می‌دهد؟

 یا Index در گیت به محلی گفته می‌شود که تغییرات فایل‌ها قبل از اعمال به تاریخچه‌ی پروژه (commit) قرار می‌گیرند. به عبارت دیگر، این مرحله به شما امکان می‌دهد که تغییرات را آماده کرده و در یک مجموعه خاص برای commit بعدی سازمان‌دهی کنید.

 محل stage یا index در گیت به محلی گفته می‌شود که تغییرات فایل‌ها قبل از کامیت شدن در آن قرار می‌گیرد. به عبارت دیگر، محل استیج این امکان را به شما می‌دهد تا مجموعه‌ای از تغییرات را آماده کرده و آن‌ها را در یک مجموعه کامیت به تاریخچه پروژه خود اضافه کنید.

 دستور `stash` تغییرات فعلی شاخه جاری را موقتا در حافظه stash ذخیره می کند و محیط کار را به حالت تمیز یا همان `clean` می‌برد. به این معنا که در این محیط تغییرات شما کاملا کنار کذاشته شده و همه چیز به وضعیت آخرین کامیت برگردانده شده است. در نتیجه شما می‌توانید روی کارهای دیگر تمرکز کنید و به طور مثلا بدون وجود تغییرات جاریتان بین شاخه‌ها جابجا شوید.

 
 ####     مفهوم snapshot به چه معناست؟ ارتباط آن با commit چیست؟
به طور کلی مفهوم snapshot به معنای تصویر یک موجودیت در یک زمان مشخص است. به طور مثال در گیت، مفهوم snapshot را می‌توان اینگونه بیان کرد که در هر لحظه، تصویری از وضعیت پروژه را در خود نگه می‌دارد. با این اوصاف می‌توان گفت هر کامیت گیت، یک تصویر کامل از تمام فایل‌ها و دایرکتوری‌های پروژه است.

این شیوه ذخیره‌سازی تاریخچه پروژه سبب می شود که جابجایی بین کامیت‌ها در طول زمان به سرعت و سادگی انجام شود. همچنین در هر لحظه، تاریخچه کاملی از تمام پروژه خود را خواهید داشت و به هر نقظه آن می‌توانید جابجا شوید.

####     تفاوت‌های local repository و remote repository چیست؟

پیشتر با مفهوم repository به عنوان محل ذخیره تاریخچه و تغییرات پروژه آشنا شدیم. در این سوال اما به تفاوت `local` و `remote‍` آن‌ می‌پردازیم.
Local repository به مخزنی اشاره دارد که روی سیستم شخصی یا محلی شما قرار دارد. در نتیجه می‌توان بدون نیاز به اینترنت و با سرعت بالا به آن دسترسی داشت.

توجه شود که در حالت `local` نیز تمام امکانات ساخت و ادغام شاخه‌ها و غیره امکان‌پذیر است و از این منظر تفاوتی با مخزن `remote` ندارد.

مخزن `remote‍` اما بر روی یک سرور مرکزی  قرار دارد که تمامی افراد بتوانند از طریق شبکه وب به آن دسترسی داشته باشند. در نتیجه، همکاری روی یک پروژه واحد را برای افراد امکان‌پذیر می‌کند. 